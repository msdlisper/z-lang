## 块级作用域额

作用域的规则
- 变量的作用域有大有小，外部变量在函数内可以访问，而函数中的本地变量，只有本地才可以访问。
- 变量的作用域，从声明以后开始。
- 在函数里，我们可以声明跟外部变量相同名称的变量，这个时候就覆盖了外部变量。

首先有栈的概念， 执行程序第一步， 需要构建全局作用域，如果解析到块级表达式， 就加一个帧栈：





## 栈
新构建的语言, 值需要得到引用还是移动所有权, 是引用, 因为很多地方需要取值; 后面实现的时候, ValType的赋值操作也是引用(rc.clone())
这样做后面如何释放动态分配的内存? 通过rust实现的Rc计数是不是隐含实现了GC机制?


在实现的语言层面, 需要实现栈结构, 栈走了后, 需要销毁, 目前栈的实现是通过rust的Struct来模拟, 在实际地址上是放到内存的堆上的
栈上的值通过Rc<ValType>存在堆上
栈上的作用域是Rc<RefCell<Scope>>也是存堆上

后面可以思考, 运行时, 作用域是否释放, 栈销毁时, 栈上的值是怎样销毁的


## 如何实现闭包

```
int c = 2;
int a () {
 int b = c;
 int d () {
   return b;
 }
 return d;
}

fn int () f = a();
f();
```

解析到a函数定义的时候, 需要a 所处的环境打包, 因为a函数里面一直能访问c


代码开始执行:, 新建frame `fg`
到a函数的定义, 将环境: 全局作用域 blockScope `sg`打包到a函数
到执行a(); 新建frame `fa`; `fa.parent = fg`
进入a代码, 进入到这个新的frame的blockScope `sa`环境, 定义了变量b, 这个时候`sa.prarent = sg`, 也就是能访问到`sa`的c
继续执行到 函数d的定义, 将`sa`的环境打包到d函数
继续执行到return语句, 将d函数返回; 这个时候销毁f1(如何销毁???), 然后回到`fg`;
这个时候将d函数赋值给f, 执行f函数;
新建frame `ff`; `ff.parent = fg`
到d函数, 这个时候的新建blockScope `sd`; `sd.parent = sa`; 所以在`sd`里面可以访问b, 以及c;
返回b的值, 这个时候需要销毁`ff`, 回到`fg`, 将b的值作为最后表达式的值


## 计算结果的处理
目前所有add表达式是需要返回int类型的, 但函数这种没有返回的情况, 就会直接报错, 需要兼容


## 增加类型校验
首先要有类型系统
int
bool
string
closure


计算机语言的分类:
- 是否运行时检查类型
  - 动态
  - 静态
- 变量类型是否可以运行期改变
  - 强类型
  - 弱类型
- 是否需要先编译
  - jit
  - aot

这里我们选择静态强类型语言
另外, 将函数列为第一公民, 如果函数的入参和返回是一样, 就代表类型一致


类型检查主要出现在几个场景中：

- 赋值语句（检查赋值操作左边和右边的类型是否匹配）。
- 变量声明语句（因为变量声明语句中也会有初始化部分，所以也需要类型匹配）。
- 函数传参（调用函数的时候，传入的参数要符合形参的要求）。
- 函数返回值（从函数中返回一个值的时候，要符合函数返回值的规定）。


























